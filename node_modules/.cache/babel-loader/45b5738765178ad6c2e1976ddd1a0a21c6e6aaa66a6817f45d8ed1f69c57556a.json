{"ast":null,"code":"import _classCallCheck from \"D:/Git/react_weather_app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Git/react_weather_app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Git/react_weather_app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Git/react_weather_app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"D:/Git/react_weather_app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { formatOffset as _formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nvar dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\"\n    });\n  }\n  return dtfCache[zone];\n}\nvar typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6\n};\nfunction hackyOffset(dtf, date) {\n  var formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    _parsed = _slicedToArray(parsed, 8),\n    fMonth = _parsed[1],\n    fDay = _parsed[2],\n    fYear = _parsed[3],\n    fadOrBc = _parsed[4],\n    fHour = _parsed[5],\n    fMinute = _parsed[6],\n    fSecond = _parsed[7];\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\nfunction partsOffset(dtf, date) {\n  var formatted = dtf.formatToParts(date);\n  var filled = [];\n  for (var i = 0; i < formatted.length; i++) {\n    var _formatted$i = formatted[i],\n      type = _formatted$i.type,\n      value = _formatted$i.value;\n    var pos = typeToPos[type];\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\nvar ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nvar IANAZone = /*#__PURE__*/function (_Zone) {\n  _inherits(IANAZone, _Zone);\n  var _super = _createSuper(IANAZone);\n  function IANAZone(name) {\n    var _this;\n    _classCallCheck(this, IANAZone);\n    _this = _super.call(this);\n    /** @private **/\n    _this.zoneName = name;\n    /** @private **/\n    _this.valid = IANAZone.isValidZone(name);\n    return _this;\n  }\n\n  /** @override **/\n  _createClass(IANAZone, [{\n    key: \"type\",\n    get: function get() {\n      return \"iana\";\n    }\n\n    /** @override **/\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.zoneName;\n    }\n\n    /** @override **/\n  }, {\n    key: \"isUniversal\",\n    get: function get() {\n      return false;\n    }\n\n    /** @override **/\n  }, {\n    key: \"offsetName\",\n    value: function offsetName(ts, _ref) {\n      var format = _ref.format,\n        locale = _ref.locale;\n      return parseZoneInfo(ts, format, locale, this.name);\n    }\n\n    /** @override **/\n  }, {\n    key: \"formatOffset\",\n    value: function formatOffset(ts, format) {\n      return _formatOffset(this.offset(ts), format);\n    }\n\n    /** @override **/\n  }, {\n    key: \"offset\",\n    value: function offset(ts) {\n      var date = new Date(ts);\n      if (isNaN(date)) return NaN;\n      var dtf = makeDTF(this.name);\n      var _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),\n        _ref3 = _slicedToArray(_ref2, 7),\n        year = _ref3[0],\n        month = _ref3[1],\n        day = _ref3[2],\n        adOrBc = _ref3[3],\n        hour = _ref3[4],\n        minute = _ref3[5],\n        second = _ref3[6];\n      if (adOrBc === \"BC\") {\n        year = -Math.abs(year) + 1;\n      }\n\n      // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n      var adjustedHour = hour === 24 ? 0 : hour;\n      var asUTC = objToLocalTS({\n        year: year,\n        month: month,\n        day: day,\n        hour: adjustedHour,\n        minute: minute,\n        second: second,\n        millisecond: 0\n      });\n      var asTS = +date;\n      var over = asTS % 1000;\n      asTS -= over >= 0 ? over : 1000 + over;\n      return (asUTC - asTS) / (60 * 1000);\n    }\n\n    /** @override **/\n  }, {\n    key: \"equals\",\n    value: function equals(otherZone) {\n      return otherZone.type === \"iana\" && otherZone.name === this.name;\n    }\n\n    /** @override **/\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return this.valid;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * @param {string} name - Zone name\n     * @return {IANAZone}\n     */\n    function create(name) {\n      if (!ianaZoneCache[name]) {\n        ianaZoneCache[name] = new IANAZone(name);\n      }\n      return ianaZoneCache[name];\n    }\n\n    /**\n     * Reset local caches. Should only be necessary in testing scenarios.\n     * @return {void}\n     */\n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      ianaZoneCache = {};\n      dtfCache = {};\n    }\n\n    /**\n     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n     * @param {string} s - The string to check validity on\n     * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n     * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n     * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n     * @return {boolean}\n     */\n  }, {\n    key: \"isValidSpecifier\",\n    value: function isValidSpecifier(s) {\n      return this.isValidZone(s);\n    }\n\n    /**\n     * Returns whether the provided string identifies a real zone\n     * @param {string} zone - The string to check\n     * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n     * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n     * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n     * @return {boolean}\n     */\n  }, {\n    key: \"isValidZone\",\n    value: function isValidZone(zone) {\n      if (!zone) {\n        return false;\n      }\n      try {\n        new Intl.DateTimeFormat(\"en-US\", {\n          timeZone: zone\n        }).format();\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n  }]);\n  return IANAZone;\n}(Zone);\nexport { IANAZone as default };","map":{"version":3,"names":["formatOffset","parseZoneInfo","isUndefined","objToLocalTS","Zone","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","era","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","name","zoneName","valid","isValidZone","ts","locale","offset","Date","isNaN","NaN","adOrBc","Math","abs","adjustedHour","asUTC","millisecond","asTS","over","otherZone","s","e"],"sources":["D:/Git/react_weather_app/node_modules/luxon/src/zones/IANAZone.js"],"sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}